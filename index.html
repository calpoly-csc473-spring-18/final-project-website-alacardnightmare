<h1 style="text-align: center;"><strong>CPE 473 Final Project: Raytracer animation and Physics</strong></h1>
<h3 style="text-align: center;"><strong>By Zachary Hatton</strong></h3>
<h3><strong>Introduction</strong></h3>
<p>For my final project I implemented animating raytraced images and physics between spheres and planes. The frame rate and duration of the animation can be specified, and any pov files can be animated, however Triangles and Boxes will not move nor collide.</p>
<p>&nbsp;</p>
<p><strong>Animation</strong></p>
<p><img src="https://alistapart.com/d/_made/d/ALA_428_Safer-Web-Animation_960_251_81.jpg" alt="Image result for animation images" /></p>
<p>The way animation in videos work is by taking a series of pictures and displaying them in a sequential order very fast to give the illusion of motion. The same concept is done in this project. With an animation of 60 Frames Per Second (FPS) each image is being displayed for 1/60&nbsp;&asymp; 0.01667 seconds before moving on to the next image. This time difference is sometimes referred to as frame time (dt) In this project, the scene is being rendered once per frame with the objects in the scene moving as if dt time has passed. The render time varies based on the complexity of the scene. All of these rendered images are then compiled to make a video file using an external program such as VirtualDUB to produce a video file.</p>
<p>&nbsp;</p>
<p><strong>Physics</strong></p>
<p>As mentioned above the motion of the objects in the scene is updated based on how much time has elapsed since the last frame. The FPS in this program can be specified as a command line argument. All of the moving objects in the scene must have an initial velocity or acting force or they will remain static. Planes are always static, and spheres are the only implemented dynamically moving objects. It can be altered in the program, but every sphere is given an inital x and z random velocity within a specified range, and a downward force of gravity is constantly acting. So all the objects will move around in the scene according to their velocity, position, and elapsed time. However, to prevent moving objects from escaping the scene, a collision system is implemented to have conservation of momentum between colliding objects.</p>
<p><img src="http://bestanimations.com/Science/Physics/newtons-pendulum-balls-potential-energy.gif" alt="physics experiment animated gif image" /></p>
<p><strong>Collision System</strong></p>
<p>After all of the velocities and new positions for every dynamic object in the scene are updated, all of the objects are checked for collisions with other objects in the collision system. Every object has a collide method determines the how each respective object will move when collided with by another object. The way this system works is that first every dynamic object in the scene calls its collide method with the planes being the other object. Positions and velocities are updated such that no object should be colliding with a plane. Then every object callls its collide method with every other object in the scene except itself. And positions and velocities are updated according to conservation of momentum. There is a parameter called elasticity which allow for some energy loss in the collision. Since it is possible that after all of the objects are collided with, there may be a new collision with a different object as a result of the collision, this process is repeated again and again until there are no more touching objects. This may not be efficient, however it guarantees that no objects will be stuck together so to speak as a result of their collision.</p>
<h3>Super Duper Shiny example video</h3>
<h3><strong><video controls="controls" width="640" height="480" data-mce-fragment="1">
<source src="Final1.mp4" /></video></strong></h3>
<h3><strong>Super Amy example video</strong></h3>
<h3><strong><video controls="controls" width="640" height="480" data-mce-fragment="1">
<source src="Final2.mp4" /></video></strong></h3>
<p>&nbsp;</p>
<h3>Software Design</h3>
<p>I think one of the most helpful abstractions in my code was to describe all interactions in the raytracing process in terms of Rays and Hits. A Ray has an origin, direction and type, with the type being either a primary, reflection or refraction ray. Then each Ray had an optional pointer to a Hit object. Each Hit contained a pointer to the object it hit, the t value, the intersection point, color info and all feeler rays.</p>
<p>By having the organization of the code in terms of chains of Rays and Hits, it greatly assisted in debugging the program to understand why a certain ray was behaving a certain way, because the entire history of the raytrace from the camera all the way to hitting nothing is recorded. Furthermore, since everything is a pointer to eachother, it does not take up a whole lot of memory. My RayTracer rarely exceeded 5Mb during runtime except for huge scenes. The details of the classes can be found in Ray.cpp/hpp and Hit.cpp/hpp.</p>